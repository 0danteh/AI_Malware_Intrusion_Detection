import os
import zipfile
import numpy as np
import cv2
import imageio
import imghdr
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, LeakyReLU

ZOO_DIR = './thezoo'
RAW_DIR = './malwareraw'
MALWARE_RAW = './malwareraw'
MALWARE_IMAGE = './malwareimages'
MALWARE_RESIZED = './malwareresize'
SAFEWARE_RAW = './safewareraw'
SAFEWARE_IMAGE = './safewareimages'
SAFEWARE_RESIZED = './safewareresize'

os.remove(os.path.join(ZOO_DIR, '.DS_Store')) if os.path.isfile(os.path.join(ZOO_DIR, '.DS_Store')) else None

unzip_list = [os.path.join(ZOO_DIR, i, j) for i in os.listdir(ZOO_DIR) for j in os.listdir(os.path.join(ZOO_DIR, i)) if j.endswith('.zip')]
unzip_password = [open(os.path.join(ZOO_DIR, i, j), "r").read().strip() for i in os.listdir(ZOO_DIR) for j in os.listdir(os.path.join(ZOO_DIR, i)) if j.endswith('.pass')]

for zip_file, password in zip(unzip_list, unzip_password):
    with zipfile.ZipFile(zip_file, 'r') as zip_ref:
        zip_ref.setpassword(bytes(password, 'utf-8'))
        zip_ref.extractall(RAW_DIR)

def convert_binary_to_image(raw_path, image_path):
    os.remove(os.path.join(image_path, ".DS_Store")) if os.path.isfile(os.path.join(image_path, ".DS_Store")) else None
    for root, files in os.walk(raw_path):
        for file in files:
            with open(os.path.join(root, file), "rb") as f:
                file_size = os.path.getsize(f.name)
                width = 256
                data = bytearray(f.read(file_size - file_size % width))
                image = np.frombuffer(data, dtype=np.uint8).reshape(-1, width)
                file_name = os.path.splitext(file)[0]
                imageio.imsave(os.path.join(image_path, file_name + '.png'), image)

def resize_image(image_path, resize_path):
    os.remove(os.path.join(image_path, ".DS_Store")) if os.path.isfile(os.path.join(image_path, ".DS_Store")) else None
    for file in os.listdir(image_path):
        image = cv2.imread(os.path.join(image_path, file))
        resized_image = cv2.resize(image, (32, 32))
        cv2.imwrite(os.path.join(resize_path, file), resized_image)

# Process safeware and malware
convert_binary_to_image(SAFEWARE_RAW, SAFEWARE_IMAGE)
resize_image(SAFEWARE_IMAGE, SAFEWARE_RESIZED)
convert_binary_to_image(MALWARE_RAW, MALWARE_IMAGE)
resize_image(MALWARE_IMAGE, MALWARE_RESIZED)

# Convert file to array
def file_to_array(file_path):
    try:
        if imghdr.what(file_path):
            return cv2.imread(file_path, cv2.IMREAD_GRAYSCALE)
        else:
            raise ValueError(f"{file_path} is not a valid image file.")
    except ValueError as e:
        print(e)

def files_to_arrays(file_paths):
    return [file_to_array(file_path) for file_path in file_paths]

safeware_arrays = files_to_arrays(SAFEWARE_RESIZED)
malware_arrays = files_to_arrays(MALWARE_RESIZED)

X = np.concatenate((safeware_arrays, malware_arrays))
y = np.concatenate((np.zeros(len(safeware_arrays)), np.ones(len(malware_arrays))))
X = (X / 255).astype('float32').reshape(X.shape[0], 32, 32, 1)
y = y.astype('int')

np.random.shuffle(X)
np.random.shuffle(y)

split_index = int(len(X) * 0.8)
X_train, X_test = X[:split_index], X[split_index:]
y_train, y_test = y[:split_index], y[split_index:]

tf.random.set_seed(20)
np.random.seed(10)

CNN_model = Sequential([
    Conv2D(32, (3, 3), input_shape=(32, 32, 1)),
    LeakyReLU(alpha=0.05),
    MaxPooling2D((2, 2)),
    Conv2D(64, (3, 3)),
    LeakyReLU(alpha=0.05),
    MaxPooling2D((2, 2)),
    Conv2D(128, (3, 3)),
    LeakyReLU(alpha=0.05),
    Flatten(),
    Dense(1, activation='sigmoid')
])

CNN_model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])

model = CNN_model.fit(X_train, y_train, batch_size=64, validation_data=(X_test, y_test), epochs=10, verbose=1)

y_pred = CNN_model.predict(X_test)
y_pred = np.round(y_pred).astype('int')

loss, accuracy = CNN_model.evaluate(X_test, y_test)

print("Loss:", loss)
print("Accuracy:", accuracy)
